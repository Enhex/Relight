////  Filename:	Lightmapper.cpp//	Created:	28:02:2012   11:03#if 0/* ========================================================================================= HEADERS & DEFS ========================================================================================= */#include	"Lightmapper.h"#include	"Lightmap.h"#include	"PhotonMap.h"#include	"DirectLightCalculator.h"#include	"IndirectLightCalculator.h"#include	<algorithm>/* ========================================================================================= CODE ========================================================================================= */// ** cLightmapper::CreateLightmapcLightmap* cLightmapper::CreateLightmap( void  ){	cLightmap *lm = new cLightmap( this );	lightmaps.push_back( lm );	return lm;}// ** cLightmapper::CreatePhotonMapcPhotonMap* cLightmapper::CreatePhotonMap( void ){	cPhotonMap *ph = new cPhotonMap( raytracer );	photonMaps.push_back( ph );	return ph;}// ** cLightmapper::CreateDirectLightCalculatorcLightmapCalculator* cLightmapper::CreateDirectLightCalculator( void ) const{	return new cDirectLightCalculator( this, raytracer );}// ** cLightmapper::CreateIndirectLightCalculatorcLightmapCalculator* cLightmapper::CreateIndirectLightCalculator( int samples, int maxDepth ) const{	cIndirectLightCalculator *lc = new cIndirectLightCalculator( this, raytracer );	lc->SetTotalIndirectSamples( samples );	lc->SetIndirectMaxDepth( maxDepth );	return lc;}// ** cLightmapper::TriangleInterpolatesVector3 cLightmapper::TriangleInterpolate( const sVector3& a, const sVector3& b, const sVector3& c, float u, float v ) {	return sVector3( a.x + (b.x - a.x) * v + (c.x - a.x) * u,                    a.y + (b.y - a.y) * v + (c.y - a.y) * u,                    a.z + (b.z - a.z) * v + (c.z - a.z) * u );}// ** cLightmapper::TriangleInterpolatesVector2 cLightmapper::TriangleInterpolate( const sVector2& a, const sVector2& b, const sVector2& c, float u, float v ) {	return sVector2( a.x + (b.x - a.x) * v + (c.x - a.x) * u,                    a.y + (b.y - a.y) * v + (c.y - a.y) * u );}// ** cLightmapper::TriangleInterpolatesColor cLightmapper::TriangleInterpolate( const sColor& a, const sColor& b, const sColor& c, float u, float v ) {	return sColor(	a.r + (b.r - a.r) * v + (c.r - a.r) * u,                  a.g + (b.g - a.g) * v + (c.g - a.g) * u,                  a.b + (b.b - a.b) * v + (c.b - a.b) * u );}// ** cLightmapper::CalculateBarycentricsVector2 cLightmapper::CalculateBarycentric( const sVector3& a, const sVector3& b, const sVector3& c, const sVector3& point ){	// ** Compute vectors	sVector3 v0 = c - a;	sVector3 v1 = b - a;	sVector3 v2 = point - a;	// ** Compute dot products	float dot00 = v0 * v0;	float dot01 = v0 * v1;	float dot02 = v0 * v2;	float dot11 = v1 * v1;	float dot12 = v1 * v2;	// ** Compute barycentric coordinates	float invDenom	= 1.0f / (dot00 * dot11 - dot01 * dot01);	float u			= (dot11 * dot02 - dot01 * dot12) * invDenom;	float v			= (dot00 * dot12 - dot01 * dot02) * invDenom;	return sVector2( u, v );}// ** cLightmapper::AddFacevoid cLightmapper::AddFace( int lightmap, const sMesh *mesh, int a, int b, int c, const sMeshVertex *vertices ){	sLMFace face;	int		indices[] = { a, b, c };	face.lightmap	= lightmap;	face.mesh		= mesh;	face.uvMin = sVector2(  1e30,  1e30 );	face.uvMax = sVector2( -1e30, -1e30 );	// ** Setup vertices	for( int i = 0; i < 3; i++ ) {		sLMVertex& v = face.vertices[i];		v.position	= vertices[ indices[i] ].position;		v.normal	= vertices[ indices[i] ].normal;		v.uv		= vertices[ indices[i] ].uv;		v.color		= vertices[ indices[i] ].color;	// ** Radiosity		// ** UV bounds		if( v.uv.x < face.uvMin.x ) face.uvMin.x = v.uv.x;		if( v.uv.x > face.uvMax.x ) face.uvMax.x = v.uv.x;		if( v.uv.y < face.uvMin.y ) face.uvMin.y = v.uv.y;		if( v.uv.y > face.uvMax.y ) face.uvMax.y = v.uv.y;	}	face.normal		= (face.vertices[0].normal + face.vertices[1].normal + face.vertices[2].normal) * (1.0f / 3.0f);	face.centroid	= (face.vertices[0].position + face.vertices[1].position + face.vertices[2].position) * (1.0f / 3.0f);	faces.push_back( face );}// ** cLightmapper::AddLightvoid cLightmapper::AddLight( const sLight& light ){	lights.push_back( light );}// ** cLightmapper::IsInsideTrianglebool cLightmapper::IsInsideTriangle( const sVector2& A, const sVector2& B, const sVector2& C, const sVector2& point ){	// ** Compute vectors	sVector2 v0 = C - A;	sVector2 v1 = B - A;	sVector2 v2 = point - A;	// ** Compute dot products	double dot00 = v0 * v0;	double dot01 = v0 * v1;	double dot02 = v0 * v2;	double dot11 = v1 * v1;	double dot12 = v1 * v2;	// ** Compute barycentric coordinates	double invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);	double _u		= (dot11 * dot02 - dot01 * dot12) * invDenom;	double _v		= (dot00 * dot12 - dot01 * dot02) * invDenom;	// ** Check if point is in triangle	return (_u >= 0.0) && (_v >= 0.0) && (_u + _v < 1.0);}// ** cLightmapper::CalculateDirectLightsLightmapCalculation* cLightmapper::CalculateDirectLight( cLightmap *lm, int row, int stride ){	cDirectLightCalculator *calculator = new cDirectLightCalculator( this, raytracer );	calculator->SetRowStride( stride );	calculator->SetStartRow( row );	calculator->SetFaceStride( stride );	calculator->SetStartFace( row );	sLightmapCalculation *c = new sLightmapCalculation;	c->lightmapper	= this;	c->lightmap		= lm;	c->calculator	= calculator;	c->isReady		= false;	pthread_create( &c->thread, NULL, Calculate, c );	return c;}// ** cLightmapper::CalculateIndirectLightsLightmapCalculation* cLightmapper::CalculateIndirectLight( cLightmap *lm, int samples, int maxDepth, int row, int stride ){	cIndirectLightCalculator *calculator = new cIndirectLightCalculator( this, raytracer );	calculator->SetTotalIndirectSamples( samples );	calculator->SetIndirectMaxDepth( maxDepth );	calculator->SetRowStride( stride );	calculator->SetStartRow( row );	sLightmapCalculation *c = new sLightmapCalculation;	c->lightmapper	= this;	c->lightmap		= lm;	c->calculator	= calculator;	pthread_create( &c->thread, NULL, Calculate, c );	return c;}// ** cLightmapper::Calculatevoid* cLightmapper::Calculate( void *userData ){	sLightmapCalculation *calc = ( sLightmapCalculation* )userData;	for( int i = 0, n = calc->lightmapper->lights.size(); i < n; i++ ) {		calc->calculator->Calculate( calc->lightmap, &calc->lightmapper->lights[i], &calc->rowsProcessed );	}	calc->isReady = true;	return NULL;}// ** cLightmapper::GetRandomDirectionsVector3 cLightmapper::GetRandomDirection( const sVector3& point, const sVector3& normal ){    // "outgoing" in a physical sense    // "outgoing_direction" is actually an incoming direction in path tracing	extern double random0to1();	extern void RotateAroundAxis( double *rotation_axis, double theta, double *vec_in, double *vec_out );    double theta = acos( sqrt( random0to1() ) );    double phi   = random0to1() * 6.28318531;	// ** TwoPi    // temporary created rondom direction    double temp[3] = { sin( theta ) * cos( phi ), sin( theta ) * sin( phi ), cos( theta ) };    // rotate "temp" such that z-axis used for sampling is aligned with "normal"    double angle_between	= acos( normal.z );	sVector3 rotation_axis;	if( fabs( normal.x ) < 0.0001f && fabs( normal.y ) < 0.0001f ) {		rotation_axis = sVector3( -normal.y, normal.z, 0.0 );	} else {		rotation_axis = sVector3( -normal.y, normal.x, 0.0 );	}	rotation_axis.normalize();	double _axis[3] = { rotation_axis.x, rotation_axis.y, rotation_axis.z };	double _out[3];    RotateAroundAxis( _axis, angle_between, temp, _out );	return sVector3( _out[0], _out[1], _out[2] );}// ** cLightmapper::CalculateUVRectvoid cLightmapper::CalculateUVRect( const sVector2& A, const sVector2& B, const sVector2& C, sVector2& min, sVector2& max ){	min.x = std::min( A.x, std::min( B.x, C.x ) );	min.y = std::min( A.y, std::min( B.y, C.y ) );	max.x = std::max( A.x, std::max( B.x, C.x ) );	max.y = std::max( A.y, std::max( B.y, C.y ) );}// ** cLightmapper::IsUVInsidebool cLightmapper::IsUVInside( const sVector2& A, const sVector2& B, const sVector2& C, float u, float v, float *bu, float *bv ){	// ** Compute vectors	sVector2 v0 = C - A;	sVector2 v1 = B - A;	sVector2 v2 = sVector2( u, v ) - A;	// ** Compute dot products	float dot00 = v0 * v0;	float dot01 = v0 * v1;	float dot02 = v0 * v2;	float dot11 = v1 * v1;	float dot12 = v1 * v2;	// ** Compute barycentric coordinates	float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);	float _u		= (dot11 * dot02 - dot01 * dot12) * invDenom;	float _v		= (dot00 * dot12 - dot01 * dot02) * invDenom;	if( bu ) *bu = _u;	if( bv ) *bv = _v;	// ** Check if point is in triangle	return (_u >= 0.0f) && (_v >= 0.0f) && (_u + _v < 1.0f);}// ** cLightmapper::TriangleAreafloat cLightmapper::TriangleArea( const sVector2& A, const sVector2& B, const sVector2& C ){	float a = (A - B).length();	float b = (B - C).length();	float c = (C - A).length();	float p = (a + b + c) * 0.5f;    	return sqrtf( p * (p - a) * (p - b) * (p - c) );}#endif